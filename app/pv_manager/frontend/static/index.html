<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PV Manager</title>
    <style>
        :root {
            color-scheme: light dark;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            --bg-color: var(--ha-card-background, #f7f7f7);
            --text-color: var(--primary-text-color, #1f1f1f);
            --card-bg: var(--card-background-color, #ffffff);
            --card-shadow: rgba(0, 0, 0, 0.06);
            --border-color: rgba(37, 99, 235, 0.45);
            --muted-text-color: rgba(15, 23, 42, 0.6);
            --secondary-text-color: rgba(30, 41, 59, 0.75);
        }
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: var(--ha-card-background, #111827);
                --text-color: var(--primary-text-color, #f9fafb);
                --card-bg: var(--card-background-color, #1f2937);
                --card-shadow: rgba(0, 0, 0, 0.35);
                --border-color: rgba(96, 165, 250, 0.65);
                --muted-text-color: rgba(248, 250, 252, 0.92);
                --secondary-text-color: rgba(226, 232, 240, 0.88);
            }
        }
        body {
            margin: 0;
            padding: clamp(1.5rem, 3vw, 2.5rem);
            background: var(--bg-color);
            color: var(--text-color);
        }
        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            margin-bottom: 2rem;
        }
        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        h1 {
            font-size: clamp(1.6rem, 2.5vw, 2rem);
            margin: 0;
        }
        main {
            max-width: 960px;
            margin: 0 auto;
        }
        .view {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }
        .view.hidden {
            display: none;
        }
        .card {
            background: var(--card-bg);
            border-radius: 12px;
            padding: clamp(1.25rem, 2vw, 1.75rem);
            box-shadow: 0 6px 16px var(--card-shadow);
        }
        .intervention-banner {
            margin-top: 1rem;
            padding: 0.75rem 1rem;
            border-radius: 10px;
            border: 1px solid rgba(148, 163, 184, 0.35);
            background: rgba(148, 163, 184, 0.12);
            font-size: 0.95rem;
            line-height: 1.45;
        }
        .intervention-banner.none {
            border-color: rgba(148, 163, 184, 0.35);
            background: rgba(148, 163, 184, 0.12);
        }
        .intervention-banner.charge {
            border-color: rgba(37, 99, 235, 0.35);
            background: rgba(37, 99, 235, 0.15);
        }
        .intervention-banner.discharge {
            border-color: rgba(34, 197, 94, 0.35);
            background: rgba(34, 197, 94, 0.18);
        }
        .intervention-banner.limit {
            border-color: rgba(249, 115, 22, 0.35);
            background: rgba(249, 115, 22, 0.18);
        }
        .intervention-banner .detail {
            display: block;
            font-size: 0.85rem;
            opacity: 0.8;
            margin-top: 0.35rem;
        }
        .settings-nav {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin: 0 0 1.25rem;
        }
        .settings-nav button {
            all: unset;
            cursor: pointer;
            border-radius: 999px;
            padding: 0.45rem 1.05rem;
            font-weight: 600;
            border: 1px solid transparent;
            background: rgba(148, 163, 184, 0.14);
            color: var(--text-color);
            transition: background 120ms ease, border-color 120ms ease;
        }
        .settings-nav button:hover {
            background: rgba(148, 163, 184, 0.22);
        }
        .settings-nav button.active {
            border-color: var(--mdc-theme-primary, #2563eb);
            background: rgba(37, 99, 235, 0.18);
            color: var(--text-color);
        }
        .settings-content {
            border: 1px solid rgba(148, 163, 184, 0.25);
            border-radius: 12px;
            padding: 1.25rem;
            background: rgba(148, 163, 184, 0.08);
        }
        .settings-panel {
            display: none;
        }
        .settings-panel.active {
            display: block;
        }
        .settings-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1rem;
            padding: 0 0.4rem;
        }
        .settings-form .field {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }
        .field label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.35rem;
            color: var(--text-color);
        }
        .field select {
            width: 100%;
            padding: 0.55rem 0.75rem;
            border-radius: 10px;
            border: 1px solid rgba(148, 163, 184, 0.35);
            background: var(--card-bg);
            color: inherit;
            font-size: 0.95rem;
            transition: border-color 120ms ease;
        }
        .field select:focus {
            outline: none;
            border-color: var(--border-color);
        }
        .field .hint {
            font-size: 0.85rem;
            margin-top: 0.35rem;
            color: var(--muted-text-color);
        }
        .field .hint.error {
            color: #dc2626;
            opacity: 1;
        }
        .field .hint .error-text {
            color: #dc2626;
            font-weight: 600;
        }
        .field .hint .warning-text {
            color: #b45309;
            font-weight: 600;
        }
        .settings-form .message {
            margin: 0;
        }
        .entity-trigger {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.5rem;
            padding: 0.65rem 0.9rem;
            border-radius: 10px;
            border: 1px solid rgba(148, 163, 184, 0.35);
            background: var(--card-bg);
            color: inherit;
            font-size: 0.95rem;
            cursor: pointer;
            transition: border-color 120ms ease, background 120ms ease;
            box-sizing: border-box;
        }
        .entity-trigger .entity-trigger-text {
            line-height: 1.2;
            flex: 1 1 auto;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .entity-trigger .entity-trigger-hint {
            line-height: 1;
            font-size: 0.85rem;
            opacity: 0.75;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 1.5rem;
            margin-left: 0.75rem;
            padding-left: 0.5rem;
            border-left: 1px solid rgba(148, 163, 184, 0.35);
            flex-shrink: 0;
            width: 1.5rem;
        }
        .entity-trigger:hover,
        .entity-trigger:focus {
            outline: none;
            border-color: var(--border-color);
            background: rgba(148, 163, 184, 0.08);
        }
        .entity-trigger[disabled] {
            cursor: not-allowed;
            opacity: 0.65;
        }
        body.modal-open {
            overflow: hidden;
        }
        .entity-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        .entity-modal.open {
            display: flex;
        }
        .entity-modal-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.45);
        }
        .entity-modal-content {
            position: relative;
            background: var(--card-bg);
            color: inherit;
            border-radius: 14px;
            box-shadow: 0 24px 55px rgba(15, 23, 42, 0.35);
            width: min(560px, 92vw);
            max-height: 80vh;
            padding: 1.25rem 1.5rem 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            z-index: 1;
        }
        .entity-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
        }
        .entity-modal-header h3 {
            margin: 0;
            font-size: 1.1rem;
        }
        .entity-modal-close {
            all: unset;
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: grid;
            place-items: center;
            border-radius: 50%;
            background: rgba(148, 163, 184, 0.18);
            transition: background 120ms ease;
        }
        .entity-modal-close:hover {
            background: rgba(148, 163, 184, 0.28);
        }
        .entity-modal-body {
            display: flex;
            flex-direction: column;
            gap: 0.85rem;
            flex: 1 1 auto;
        }
        #entitySearch {
            width: 100%;
            padding: 0.65rem 0.75rem;
            border-radius: 10px;
            border: 1px solid rgba(148, 163, 184, 0.35);
            background: var(--card-bg);
            color: inherit;
            font-size: 0.95rem;
        }
        #entitySearch:focus {
            outline: none;
            border-color: var(--border-color);
        }
        .entity-list {
            border: 1px solid rgba(148, 163, 184, 0.28);
            border-radius: 10px;
            overflow-y: auto;
            max-height: 52vh;
        }
        .entity-option {
            all: unset;
            display: block;
            width: 100%;
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid rgba(148, 163, 184, 0.18);
        }
        .entity-option:hover,
        .entity-option:focus {
            background: rgba(37, 99, 235, 0.12);
        }
        .entity-option .entity-name {
            font-weight: 600;
        }
        .entity-option .entity-meta {
            font-size: 0.85rem;
            opacity: 0.75;
            margin-top: 0.25rem;
        }
        .entity-option.selected {
            background: rgba(37, 99, 235, 0.15);
            border-left: 3px solid var(--mdc-theme-primary, #2563eb);
        }
        .entity-list .entity-option:last-child {
            border-bottom: none;
        }
        .entity-empty {
            padding: 1.25rem;
            text-align: center;
            font-size: 0.9rem;
            opacity: 0.75;
        }
        .entity-modal-footer {
            display: flex;
            justify-content: flex-end;
        }
        .entity-modal-footer button {
            all: unset;
            cursor: pointer;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            background: rgba(148, 163, 184, 0.18);
            color: inherit;
            font-weight: 600;
        }
        .entity-modal-footer button:hover {
            background: rgba(148, 163, 184, 0.28);
        }
        .card h2 {
            margin: 0 0 0.5rem;
            font-size: clamp(1.25rem, 1.8vw, 1.5rem);
        }
        .status-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }
        .status-row span.label {
            font-weight: 600;
        }
        .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #cccccc;
            flex-shrink: 0;
        }
        .dot.ok {
            background: #22c55e;
        }
        .actions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            margin-top: 1rem;
        }
        button {
            all: unset;
            cursor: pointer;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            background: var(--mdc-theme-primary, #2563eb);
            color: #ffffff;
            font-weight: 600;
            transition: background 120ms ease;
        }
        button:hover {
            background: #1d4ed8;
        }
        button.secondary {
            background: transparent;
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }
        button.secondary:hover {
            background: rgba(37, 99, 235, 0.12);
        }
        button[disabled] {
            opacity: 0.65;
            cursor: not-allowed;
        }
        .actions button {
            flex-shrink: 0;
        }
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-top: 1.25rem;
        }
        .summary-item {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        .summary-label {
            font-size: 0.75rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--secondary-text-color);
        }
        .summary-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-color);
        }
        .meta {
            font-size: 0.9rem;
            color: var(--secondary-text-color);
            margin: 0.25rem 0 1rem;
        }
        .message {
            font-size: 0.9rem;
            color: var(--secondary-text-color);
            margin-bottom: 1rem;
        }
        .message.error {
            color: #dc2626;
        }
        canvas {
            width: 100%;
            max-height: 340px;
        }
        .training-state {
            font-size: 0.9rem;
            color: var(--secondary-text-color, #555555);
            margin-top: 0.75rem;
        }
        .training-state.running {
            color: #d97706;
        }
        .training-state.error {
            color: #dc2626;
        }
        @media (max-width: 720px) {
            header {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.75rem;
            }
            main {
                width: 100%;
            }
            .card {
                padding: 1.25rem;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js" defer></script>
</head>
<body>
    <header>
        <div class="header-left">
            <img src="https://fonts.gstatic.com/s/i/materialiconsoutlined/solar_power/v11/24px.svg" alt="PV" />
            <h1>PV Manager</h1>
        </div>
        <button type="button" class="secondary" id="settingsBtn">Settings</button>
    </header>
    <main>
        <div id="mainView" class="view">
        <section class="card">
            <h2>Add-on Status</h2>
            <div id="status" class="status-row">
                <span class="dot"></span>
                <span class="label" id="statusLabel">Loading status…</span>
            </div>
            <div id="error" class="message error"></div>
            <div class="summary-grid" id="summaryGrid">
                <div class="summary-item">
                    <span class="summary-label">Import (kWh)</span>
                    <span class="summary-value" id="summary-import">--</span>
                </div>
                <div class="summary-item">
                    <span class="summary-label">Export (kWh)</span>
                    <span class="summary-value" id="summary-export">--</span>
                </div>
                <div class="summary-item">
                    <span class="summary-label">Net Cost (€)</span>
                    <span class="summary-value" id="summary-net">--</span>
                </div>
                <div class="summary-item">
                    <span class="summary-label">Peak Import (kW)</span>
                    <span class="summary-value" id="summary-peak-import">--</span>
                </div>
                <div class="summary-item">
                    <span class="summary-label">Peak Export (kW)</span>
                    <span class="summary-value" id="summary-peak-export">--</span>
                </div>
            </div>
            <div id="summaryWindow" class="meta"></div>
            <div id="trainingState" class="training-state">Training status unknown.</div>
            <div id="trainingError" class="training-state error" style="display:none;"></div>
            <div id="cycleMessage" class="message" style="display:none;"></div>
            <div class="actions">
                <button type="button" class="secondary" id="refreshBtn">Refresh Data</button>
                <button type="button" id="cycleBtn">Recompute Plan</button>
                <button type="button" id="trainBtn">Trigger Training</button>
            </div>
        </section>

        <section class="card">
            <h2>Forecast vs Load</h2>
            <p class="meta">Last updated: <span id="lastUpdated">waiting…</span></p>
            <div id="forecastMessage" class="message"></div>
            <canvas id="forecastChart" height="320"></canvas>
        </section>

        <section class="card">
            <h2>Optimization Plan</h2>
            <canvas id="planChart" height="320"></canvas>
            <div id="interventionBanner" class="intervention-banner none">Current intervention: Waiting for forecast…</div>
        </section>

        <section class="card">
            <h2>Recent Measurements (24h)</h2>
            <canvas id="historyChart" height="280"></canvas>
        </section>
        </div>
        <div id="settingsView" class="view hidden">
            <section class="card">
                <h2>Settings</h2>
                <nav class="settings-nav">
                    <button type="button" data-settings-tab="inverter" class="active">Inverter</button>
                    <button type="button" data-settings-tab="battery">Battery</button>
                    <button type="button" data-settings-tab="pv">PV System</button>
                    <button type="button" data-settings-tab="prices">Energy Prices</button>
                    <button type="button" data-settings-tab="loads">Flexible Loads</button>
                </nav>
                <div class="settings-content">
                    <div data-settings-panel="inverter" class="settings-panel active">
                        <h3>Inverter Settings</h3>
                        <p class="message">Select which Home Assistant statistics feed the house consumption and PV power forecasts. Values are normalized to kW automatically.</p>
                        <form id="inverterForm" class="settings-form" autocomplete="off">
                            <div class="field">
                                <label for="houseEntityTrigger">House consumption sensor</label>
                                <button type="button" id="houseEntityTrigger" class="entity-trigger" data-target="house_consumption">
                                    <span class="entity-trigger-text" id="houseEntityLabel">Loading…</span>
                                    <span class="entity-trigger-hint" aria-hidden="true">⌄</span>
                                </button>
                                <p class="hint" id="houseHint">Waiting for Home Assistant…</p>
                            </div>
                            <div class="field">
                                <label for="pvEntityTrigger">PV production sensor</label>
                                <button type="button" id="pvEntityTrigger" class="entity-trigger" data-target="pv_power">
                                    <span class="entity-trigger-text" id="pvEntityLabel">Loading…</span>
                                    <span class="entity-trigger-hint" aria-hidden="true">⌄</span>
                                </button>
                                <p class="hint" id="pvHint">Waiting for Home Assistant…</p>
                            </div>
                            <p class="message" id="inverterMessage" style="display:none;"></p>
                        </form>
                    </div>
                    <div data-settings-panel="battery" class="settings-panel">
                        <h3>Battery Settings</h3>
                        <p class="message">Set battery capacity, charge/discharge rates, and reserve thresholds.</p>
                    </div>
                    <div data-settings-panel="pv" class="settings-panel">
                        <h3>PV System Settings</h3>
                        <p class="message">Manage installed PV capacity, panel orientation, and performance factors.</p>
                    </div>
                    <div data-settings-panel="prices" class="settings-panel">
                        <h3>Energy Price Settings</h3>
                        <p class="message">Connect to tariff providers or override price profiles for optimization.</p>
                    </div>
                    <div data-settings-panel="loads" class="settings-panel">
                        <h3>Flexible Loads</h3>
                        <p class="message">Schedule controllable appliances and flexibility windows for automation.</p>
                    </div>
                </div>
            </section>
        </div>
    </main>
    <div id="entityModal" class="entity-modal" role="dialog" aria-modal="true" aria-labelledby="entityModalTitle">
        <div id="entityModalBackdrop" class="entity-modal-backdrop"></div>
        <div class="entity-modal-content">
            <div class="entity-modal-header">
                <h3 id="entityModalTitle">Select sensor</h3>
                <button type="button" id="entityModalClose" class="entity-modal-close" aria-label="Close selector">×</button>
            </div>
            <div class="entity-modal-body">
                <input type="search" id="entitySearch" placeholder="Search sensors…" autocomplete="off" />
                <div id="entityList" class="entity-list" role="listbox" aria-labelledby="entityModalTitle"></div>
            </div>
            <div class="entity-modal-footer">
                <button type="button" id="entityModalCancel">Cancel</button>
            </div>
        </div>
    </div>
    <script>
    let numberFmt1 = new Intl.NumberFormat(undefined, { maximumFractionDigits: 1, minimumFractionDigits: 0 });
    let numberFmt2 = new Intl.NumberFormat(undefined, { maximumFractionDigits: 2, minimumFractionDigits: 0 });
    let currencyFmt = new Intl.NumberFormat(undefined, { style: 'currency', currency: 'EUR', maximumFractionDigits: 2 });

        let activeLocale = navigator.language || undefined;
        let haTimeZone;
        let timeFormatter;
        let dateTimeFormatter;

        let forecastChart;
        let planChart;
        let historyChart;
        let priceImputedFlags = [];
        let showingSettings = false;
    let statisticsCatalog = [];
    let inverterSettings = null;
    let inverterBusy = false;
    let entityCatalog = [];
    let powerEntityCatalog = [];
    let entityLookup = Object.create(null);
    let entityModalTarget = null;
    let lastEntityTrigger = null;
    let lastTrainingRunning = false;
    let lastCycleRunning = false;
    let autoRefreshTimer = null;
    let pendingForecastRefresh = null;
    const houseTrigger = document.getElementById('houseEntityTrigger');
    const pvTrigger = document.getElementById('pvEntityTrigger');
    const houseLabel = document.getElementById('houseEntityLabel');
    const pvLabel = document.getElementById('pvEntityLabel');
    const houseHint = document.getElementById('houseHint');
    const pvHint = document.getElementById('pvHint');
    const inverterMessage = document.getElementById('inverterMessage');
    const entityModal = document.getElementById('entityModal');
    const entityModalBackdrop = document.getElementById('entityModalBackdrop');
    const entityModalClose = document.getElementById('entityModalClose');
    const entityModalCancel = document.getElementById('entityModalCancel');
    const entitySearchInput = document.getElementById('entitySearch');
    const entityListContainer = document.getElementById('entityList');

        function computeHourCycle(locale) {
            if (!locale) return undefined;
            return locale.toLowerCase().startsWith('cs') ? 'h23' : undefined;
        }

        function updateFormattingContext(locale, timeZone) {
            if (locale) {
                activeLocale = locale;
            } else if (!activeLocale) {
                activeLocale = navigator.language || undefined;
            }
            if (timeZone) {
                haTimeZone = timeZone;
            }
            const resolvedLocale = activeLocale;
            const hourCycle = computeHourCycle(resolvedLocale);
            const timeOptions = { hour: '2-digit', minute: '2-digit' };
            const dateTimeOptions = { weekday: 'short', day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' };
            if (haTimeZone) {
                timeOptions.timeZone = haTimeZone;
                dateTimeOptions.timeZone = haTimeZone;
            }
            if (hourCycle) {
                timeOptions.hourCycle = hourCycle;
                dateTimeOptions.hourCycle = hourCycle;
            }
            timeFormatter = new Intl.DateTimeFormat(resolvedLocale, timeOptions);
            dateTimeFormatter = new Intl.DateTimeFormat(resolvedLocale, dateTimeOptions);
            numberFmt1 = new Intl.NumberFormat(resolvedLocale, { maximumFractionDigits: 1, minimumFractionDigits: 0 });
            numberFmt2 = new Intl.NumberFormat(resolvedLocale, { maximumFractionDigits: 2, minimumFractionDigits: 0 });
            currencyFmt = new Intl.NumberFormat(resolvedLocale, { style: 'currency', currency: 'EUR', maximumFractionDigits: 2 });
            const chartLocale = activeLocale || undefined;
            if (typeof Chart !== 'undefined' && Chart.defaults) {
                Chart.defaults.locale = chartLocale;
            }
            applyLocaleToCharts();
        }

        function ensureFormatters() {
            if (!timeFormatter || !dateTimeFormatter) {
                updateFormattingContext(activeLocale, haTimeZone);
            }
        }

        function applyLocaleToCharts() {
            const locale = activeLocale || undefined;
            if (forecastChart) {
                forecastChart.options.locale = locale;
            }
            if (planChart) {
                planChart.options.locale = locale;
            }
            if (historyChart) {
                historyChart.options.locale = locale;
            }
        }

        function formatDateTime(iso) {
            if (!iso) return '--';
            ensureFormatters();
            const dt = new Date(iso);
            if (Number.isNaN(dt.getTime())) return '--';
            return dateTimeFormatter.format(dt);
        }

        function formatTickLabel(iso) {
            if (!iso) return '';
            ensureFormatters();
            const dt = new Date(iso);
            if (Number.isNaN(dt.getTime())) return '';
            return timeFormatter.format(dt);
        }

        function sanitizeSeries(values, scale = 1) {
            return values.map((value) => {
                const num = Number(value);
                if (!Number.isFinite(num)) {
                    return 0;
                }
                return num * scale;
            });
        }

        function updateViewMode() {
            const mainView = document.getElementById('mainView');
            const settingsView = document.getElementById('settingsView');
            const settingsBtn = document.getElementById('settingsBtn');
            if (!mainView || !settingsView || !settingsBtn) {
                return;
            }
            if (showingSettings) {
                mainView.classList.add('hidden');
                settingsView.classList.remove('hidden');
                settingsBtn.textContent = 'Back';
            } else {
                mainView.classList.remove('hidden');
                settingsView.classList.add('hidden');
                settingsBtn.textContent = 'Settings';
            }
        }

        function toggleSettings() {
            showingSettings = !showingSettings;
            if (showingSettings) {
                if (autoRefreshTimer) {
                    clearTimeout(autoRefreshTimer);
                    autoRefreshTimer = null;
                }
                if (pendingForecastRefresh) {
                    clearTimeout(pendingForecastRefresh);
                    pendingForecastRefresh = null;
                }
            }
            updateViewMode();
            if (showingSettings) {
                loadSettingsData();
            } else {
                refreshStatus();
                refreshForecast();
            }
        }

        function activateSettingsTab(tab) {
            const buttons = document.querySelectorAll('.settings-nav button');
            const panels = document.querySelectorAll('.settings-panel');
            buttons.forEach((btn) => {
                if (btn.dataset.settingsTab === tab) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            panels.forEach((panel) => {
                if (panel.dataset.settingsPanel === tab) {
                    panel.classList.add('active');
                } else {
                    panel.classList.remove('active');
                }
            });
        }

        function renderIntervention(intervention, fallbackText) {
            ensureFormatters();
            const el = document.getElementById('interventionBanner');
            if (!el) {
                return;
            }
            const classes = ['none', 'charge', 'discharge', 'limit'];
            classes.forEach((cls) => el.classList.remove(cls));

            if (!intervention) {
                const text = fallbackText || 'Current intervention: Eco mode';
                el.classList.add('none');
                el.innerHTML = text;
                el.style.display = 'block';
                return;
            }

            const mode = intervention.mode || 'none';
            const power = Number(intervention.power_kw);
            const price = Number(intervention.price_eur_per_kwh);
            const soc = Number(intervention.soc);
            const reason = typeof intervention.reason === 'string' ? intervention.reason.trim() : '';

            let mainText = 'Current intervention: Eco mode';
            let modeClass = 'none';

            if (mode === 'charge') {
                if (Number.isFinite(power) && power > 0.05) {
                    mainText = `Current intervention: Charge battery at ${numberFmt1.format(power)} kW`;
                } else {
                    mainText = 'Current intervention: Charge battery';
                }
                modeClass = 'charge';
            } else if (mode === 'discharge') {
                if (Number.isFinite(power) && power > 0.05) {
                    mainText = `Current intervention: Discharge battery at ${numberFmt1.format(power)} kW`;
                } else {
                    mainText = 'Current intervention: Discharge battery';
                }
                modeClass = 'discharge';
            } else if (mode === 'limit_export') {
                if (Number.isFinite(power) && power > 0.05) {
                    mainText = `Current intervention: Limit grid export to ${numberFmt1.format(power)} kW`;
                } else {
                    mainText = 'Current intervention: Limit grid export';
                }
                modeClass = 'limit';
            } else {
                if (fallbackText) {
                    mainText = fallbackText;
                }
                modeClass = 'none';
            }

            const detailParts = [];
            if (modeClass !== 'none' && Number.isFinite(price)) {
                detailParts.push(`${currencyFmt.format(price)} / kWh`);
            }
            if (modeClass !== 'none' && Number.isFinite(soc)) {
                detailParts.push(`SoC ${numberFmt2.format(soc * 100)} %`);
            }
            if (reason) {
                detailParts.push(reason);
            }

            el.classList.add(modeClass);
            el.style.display = 'block';
            if (detailParts.length) {
                el.innerHTML = `${mainText}<span class="detail">${detailParts.join(' • ')}</span>`;
            } else {
                el.innerHTML = mainText;
            }
        }

        async function fetchJson(url, options) {
            const response = await fetch(url, options);
            if (!response.ok) {
                const text = await response.text();
                try {
                    const parsed = JSON.parse(text);
                    const detail = parsed.detail || parsed.message;
                    throw new Error(detail || `HTTP ${response.status}`);
                } catch (_) {
                    throw new Error(text || `HTTP ${response.status}`);
                }
            }
            return response.json();
        }

        function statisticSupportsMean(item) {
            if (!item || typeof item !== 'object') return false;
            if (item.has_mean) return true;
            const supported = item.supported_statistics;
            if (Array.isArray(supported)) {
                return supported.some((entry) => String(entry).toLowerCase() === 'mean');
            }
            return false;
        }

        function statisticLabel(item) {
            if (!item) return '';
            const name = item.display_name || item.statistic_id || '';
            return item.unit ? `${name} (${item.unit})` : name;
        }

        function setInverterMessage(text, kind = 'info') {
            if (!inverterMessage) return;
            if (!text) {
                inverterMessage.style.display = 'none';
                inverterMessage.classList.remove('error');
                inverterMessage.textContent = '';
                return;
            }
            inverterMessage.style.display = 'block';
            if (kind === 'error') {
                inverterMessage.classList.add('error');
            } else {
                inverterMessage.classList.remove('error');
            }
            inverterMessage.textContent = text;
        }

        function renderInverterHints() {
            if (!inverterSettings) return;
            const catalogMap = Object.create(null);
            statisticsCatalog.forEach((item) => {
                if (item && item.statistic_id) {
                    catalogMap[item.statistic_id] = item;
                }
            });
            const house = inverterSettings.house_consumption || {};
            const pv = inverterSettings.pv_power || {};
            const applyHint = (el, selection) => {
                if (!el || !selection) return;
                const meta = catalogMap[selection.entity_id];
                const status = selection.recorder_status || (meta ? (statisticSupportsMean(meta) ? 'ok' : 'no_mean') : 'missing');
                el.classList.remove('error');
                el.textContent = '';
                if (status === 'missing') {
                    const warning = document.createElement('span');
                    warning.className = 'error-text';
                    warning.textContent = 'Recorder entry missing. Refresh statistics if this looks wrong.';
                    el.appendChild(warning);
                    el.classList.add('error');
                } else if (status === 'no_mean') {
                    const note = document.createElement('span');
                    note.className = 'warning-text';
                    note.textContent = ' Recorder metadata does not list mean values. Forecasts will still attempt to use the statistic.';
                    el.appendChild(note);
                }
            };
            applyHint(houseHint, house);
            applyHint(pvHint, pv);
        }

        function filterPowerEntities(list) {
            const allowedUnits = new Set(['w', 'kw', 'mw', 'wh', 'kwh', 'mwh']);
            return list.filter((item) => {
                if (!item || !item.entity_id) return false;
                if (item.domain && item.domain !== 'sensor') return false;
                const deviceClass = (item.device_class || '').toLowerCase();
                const unit = (item.unit || '').toLowerCase();
                if (deviceClass === 'power' || deviceClass === 'energy') {
                    return true;
                }
                return allowedUnits.has(unit);
            });
        }

        function getEntityMeta(entityId) {
            return (entityId && entityLookup[entityId]) || null;
        }

        function entityButtonLabel(selection, fallback) {
            if (!selection) return fallback;
            const meta = getEntityMeta(selection.entity_id);
            if (meta) {
                const unit = meta.unit ? ` (${meta.unit})` : '';
                return `${meta.name}${unit}`;
            }
            if (selection.entity_id) {
                return selection.entity_id;
            }
            return fallback;
        }

        function updateEntityButton(button, labelEl, selection, fallback) {
            if (!button || !labelEl) return;
            labelEl.textContent = entityButtonLabel(selection, fallback);
            if (inverterBusy || !powerEntityCatalog.length) {
                button.setAttribute('disabled', 'disabled');
            } else {
                button.removeAttribute('disabled');
            }
            button.dataset.entityId = selection && selection.entity_id ? selection.entity_id : '';
        }

        function renderInverterForm() {
            if (!inverterSettings) return;
            updateEntityButton(houseTrigger, houseLabel, inverterSettings.house_consumption, 'Select house sensor');
            updateEntityButton(pvTrigger, pvLabel, inverterSettings.pv_power, 'Select PV sensor');
            renderInverterHints();
            const recorderStatuses = [
                inverterSettings.house_consumption && inverterSettings.house_consumption.recorder_status,
                inverterSettings.pv_power && inverterSettings.pv_power.recorder_status,
            ];
            if (recorderStatuses.every((value) => value === 'missing')) {
                setInverterMessage('No Home Assistant statistics were returned for the selected sensors. Verify long-term statistics are enabled.', 'error');
            } else if (!powerEntityCatalog.length) {
                setInverterMessage('No power sensors detected. Expose Home Assistant sensors with power readings to proceed.', 'error');
            }
        }

        async function loadSettingsData() {
            try {
                const payload = await fetchJson('/api/settings');
                statisticsCatalog = Array.isArray(payload.statistics) ? payload.statistics : [];
                entityCatalog = Array.isArray(payload.entities) ? payload.entities : [];
                entityLookup = Object.create(null);
                entityCatalog.forEach((item) => {
                    if (item && item.entity_id) {
                        entityLookup[item.entity_id] = item;
                    }
                });
                powerEntityCatalog = filterPowerEntities(entityCatalog);
                inverterSettings = payload.settings && payload.settings.inverter ? payload.settings.inverter : null;
                renderInverterForm();
                const recorderStatuses = [
                    inverterSettings && inverterSettings.house_consumption && inverterSettings.house_consumption.recorder_status,
                    inverterSettings && inverterSettings.pv_power && inverterSettings.pv_power.recorder_status,
                ];
                if (recorderStatuses.some((value) => value !== 'missing') && powerEntityCatalog.length) {
                    setInverterMessage('');
                }
            } catch (err) {
                setInverterMessage(err instanceof Error ? err.message : String(err), 'error');
            }
        }

        function setEntityTriggersDisabled(disabled) {
            [houseTrigger, pvTrigger].forEach((btn) => {
                if (!btn) return;
                if (disabled) {
                    btn.setAttribute('disabled', 'disabled');
                } else {
                    btn.removeAttribute('disabled');
                }
            });
        }

        async function updateInverterSelection(key, entityId) {
            if (!inverterSettings || inverterBusy) return;
            const current = inverterSettings[key] ? inverterSettings[key].entity_id : null;
            if (!entityId || entityId === current) return;
            inverterBusy = true;
            setEntityTriggersDisabled(true);
            setInverterMessage('Saving selection…');
            try {
                const payload = await fetchJson('/api/settings/inverter', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ [key]: { entity_id: entityId } }),
                });
                if (Array.isArray(payload.statistics)) {
                    statisticsCatalog = payload.statistics;
                }
                if (Array.isArray(payload.entities)) {
                    entityCatalog = payload.entities;
                    entityLookup = Object.create(null);
                    entityCatalog.forEach((item) => {
                        if (item && item.entity_id) {
                            entityLookup[item.entity_id] = item;
                        }
                    });
                    powerEntityCatalog = filterPowerEntities(entityCatalog);
                }
                if (payload.settings && payload.settings.inverter) {
                    inverterSettings = payload.settings.inverter;
                }
                renderInverterForm();
                setInverterMessage('Saved. Re-run training to refresh the models with the new inputs.', 'success');
            } catch (err) {
                setInverterMessage(err instanceof Error ? err.message : String(err), 'error');
            } finally {
                inverterBusy = false;
                setEntityTriggersDisabled(false);
            }
        }

        function openEntityModal(target) {
            if (!entityModal) return;
            if (!powerEntityCatalog.length) {
                setInverterMessage('No power sensors detected. Expose Home Assistant sensors with power readings to proceed.', 'error');
                return;
            }
            entityModalTarget = target;
            lastEntityTrigger = target === 'pv_power' ? pvTrigger : houseTrigger;
            const modalTitle = document.getElementById('entityModalTitle');
            if (modalTitle) {
                modalTitle.textContent = target === 'pv_power' ? 'Select PV sensor' : 'Select house sensor';
            }
            if (entitySearchInput) {
                entitySearchInput.value = '';
            }
            renderEntityList('');
            entityModal.classList.add('open');
            document.body.classList.add('modal-open');
            if (entitySearchInput) {
                setTimeout(() => entitySearchInput.focus(), 0);
            }
        }

        function closeEntityModal() {
            if (!entityModal) return;
            entityModal.classList.remove('open');
            document.body.classList.remove('modal-open');
            const trigger = lastEntityTrigger;
            entityModalTarget = null;
            lastEntityTrigger = null;
            if (trigger) {
                trigger.focus();
            }
        }

        function matchesEntity(item, term) {
            if (!term) return true;
            const haystack = `${item.name || ''} ${item.entity_id}`.toLowerCase();
            return haystack.includes(term);
        }

        function renderEntityList(searchTerm) {
            if (!entityListContainer) return;
            const term = (searchTerm || '').trim().toLowerCase();
            const items = powerEntityCatalog.filter((item) => matchesEntity(item, term));
            entityListContainer.textContent = '';
            if (!items.length) {
                const empty = document.createElement('div');
                empty.className = 'entity-empty';
                empty.textContent = term ? 'No matching sensors found.' : 'No power sensors available.';
                entityListContainer.appendChild(empty);
                return;
            }
            const current = entityModalTarget && inverterSettings && inverterSettings[entityModalTarget]
                ? inverterSettings[entityModalTarget].entity_id
                : null;
            items.forEach((item) => {
                const option = document.createElement('button');
                option.type = 'button';
                option.className = 'entity-option';
                option.setAttribute('role', 'option');
                option.dataset.entityId = item.entity_id;
                option.innerHTML = `
                    <span class="entity-name">${item.name}</span>
                    <span class="entity-meta">${item.entity_id}${item.unit ? ` • ${item.unit}` : ''}</span>
                `;
                if (item.entity_id === current) {
                    option.classList.add('selected');
                }
                option.addEventListener('click', () => {
                    const targetKey = entityModalTarget;
                    closeEntityModal();
                    if (targetKey) {
                        updateInverterSelection(targetKey, item.entity_id);
                    }
                });
                entityListContainer.appendChild(option);
            });
        }

        function updateSummary(summary) {
            const mapping = [
                { key: 'import_kwh', id: 'summary-import', format: (v) => numberFmt1.format(v) },
                { key: 'export_kwh', id: 'summary-export', format: (v) => numberFmt1.format(v) },
                { key: 'net_cost_eur', id: 'summary-net', format: (v) => currencyFmt.format(v) },
                { key: 'peak_import_kw', id: 'summary-peak-import', format: (v) => numberFmt2.format(v) },
                { key: 'peak_export_kw', id: 'summary-peak-export', format: (v) => numberFmt2.format(v) },
            ];
            if (!summary) {
                mapping.forEach((item) => {
                    const el = document.getElementById(item.id);
                    el.textContent = '--';
                });
                return;
            }
            mapping.forEach((item) => {
                const el = document.getElementById(item.id);
                const value = Number(summary[item.key]);
                el.textContent = Number.isFinite(value) ? item.format(value) : '--';
            });
        }

        function applyStatus(payload) {
            const dot = document.querySelector('#status .dot');
            const label = document.getElementById('statusLabel');
            const errorEl = document.getElementById('error');
            const trainingStateEl = document.getElementById('trainingState');
            const trainingErrorEl = document.getElementById('trainingError');
            const trainBtn = document.getElementById('trainBtn');
            const haError = payload.home_assistant_error || null;
            const cycleBtn = document.getElementById('cycleBtn');
            const cycleMessageEl = document.getElementById('cycleMessage');
            const summaryWindowEl = document.getElementById('summaryWindow');

            if (!haError && payload.snapshot_available) {
                dot.classList.add('ok');
                label.textContent = 'Service online';
            } else if (!haError) {
                dot.classList.remove('ok');
                label.textContent = 'Waiting for forecast…';
                if (summaryWindowEl) {
                    summaryWindowEl.textContent = '';
                }
                renderIntervention(null, 'Current intervention: Waiting for forecast…');
            } else {
                dot.classList.remove('ok');
                label.textContent = 'Home Assistant unavailable';
                if (summaryWindowEl) {
                    summaryWindowEl.textContent = '';
                }
                renderIntervention(null, 'Current intervention unavailable until Home Assistant connects');
            }

            const errorMessages = [];
            if (haError) {
                errorMessages.push(haError);
            }
            errorEl.textContent = errorMessages.join(' ');

            const training = payload.training || {};
            if (training.running) {
                trainingStateEl.textContent = training.started_at
                    ? `Training in progress (started ${formatDateTime(training.started_at)})`
                    : 'Training in progress…';
                trainingStateEl.classList.add('running');
                trainBtn.textContent = 'Training…';
                trainBtn.disabled = true;
            } else if (haError) {
                trainingStateEl.textContent = 'Training unavailable until Home Assistant connects';
                trainingStateEl.classList.remove('running');
                trainBtn.textContent = 'Trigger Training';
                trainBtn.disabled = true;
            } else {
                trainingStateEl.textContent = training.finished_at
                    ? `Last trained ${formatDateTime(training.finished_at)}`
                    : 'Training idle';
                trainingStateEl.classList.remove('running');
                trainBtn.textContent = 'Trigger Training';
                trainBtn.disabled = false;
            }

            if (training.error) {
                trainingErrorEl.style.display = 'block';
                trainingErrorEl.textContent = `Last training error: ${training.error}`;
            } else {
                trainingErrorEl.style.display = 'none';
                trainingErrorEl.textContent = '';
            }

            if (cycleMessageEl) {
                if (payload.cycle_running) {
                    cycleMessageEl.style.display = 'block';
                    cycleMessageEl.classList.remove('error');
                    cycleMessageEl.textContent = 'Optimization cycle running…';
                    cycleMessageEl.dataset.auto = 'running';
                } else if (cycleMessageEl.dataset.auto === 'running') {
                    cycleMessageEl.style.display = 'none';
                    cycleMessageEl.textContent = '';
                    delete cycleMessageEl.dataset.auto;
                }
            }

            if (cycleBtn) {
                if (haError) {
                    cycleBtn.disabled = true;
                    cycleBtn.textContent = 'Recompute Plan';
                } else if (payload.cycle_running) {
                    cycleBtn.disabled = true;
                    cycleBtn.textContent = 'Recomputing…';
                } else {
                    cycleBtn.disabled = false;
                    cycleBtn.textContent = 'Recompute Plan';
                }
            }

            updateSummary(payload.summary);

            const trainingRunning = Boolean(training.running);
            const cycleRunningState = Boolean(payload.cycle_running);
            const trainingCompleted = lastTrainingRunning && !trainingRunning;
            const cycleCompleted = lastCycleRunning && !cycleRunningState;

            lastTrainingRunning = trainingRunning;
            lastCycleRunning = cycleRunningState;

            if (autoRefreshTimer) {
                clearTimeout(autoRefreshTimer);
                autoRefreshTimer = null;
            }
            if (!showingSettings && (trainingRunning || cycleRunningState)) {
                autoRefreshTimer = window.setTimeout(() => {
                    autoRefreshTimer = null;
                    refreshStatus();
                }, 15000);
            }

            const shouldRefreshForecast = !showingSettings && (trainingCompleted || cycleCompleted);
            if (shouldRefreshForecast) {
                if (pendingForecastRefresh) {
                    clearTimeout(pendingForecastRefresh);
                }
                pendingForecastRefresh = window.setTimeout(() => {
                    pendingForecastRefresh = null;
                    refreshForecast();
                }, 1200);
            }
        }

        function ensureForecastChart() {
            if (forecastChart) return;
            const ctx = document.getElementById('forecastChart');
            forecastChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'PV forecast (kW)',
                            data: [],
                            borderColor: '#22c55e',
                            backgroundColor: 'rgba(34, 197, 94, 0.12)',
                            fill: true,
                            tension: 0.25,
                        },
                        {
                            label: 'Load forecast (kW)',
                            data: [],
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.08)',
                            fill: false,
                            tension: 0.25,
                        },
                        {
                            label: 'Price (€/kWh)',
                            data: [],
                            borderColor: '#6366f1',
                            fill: false,
                            tension: 0.15,
                            yAxisID: 'y1',
                            pointRadius: 0,
                            pointHitRadius: 7,
                        },
                    ],
                },
                options: {
                    locale: activeLocale || undefined,
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    scales: {
                        x: {
                            ticks: { maxRotation: 0, autoSkip: true },
                        },
                        y: {
                            title: { display: true, text: 'Power (kW)' },
                            beginAtZero: true,
                        },
                        y1: {
                            position: 'right',
                            title: { display: true, text: '€/kWh' },
                            grid: { drawOnChartArea: false },
                        },
                    },
                    plugins: {
                        legend: { display: true },
                        tooltip: {
                            callbacks: {
                                afterLabel(context) {
                                    if (!priceImputedFlags.length) {
                                        return '';
                                    }
                                    return priceImputedFlags[context.dataIndex] ? 'Imputed from previous day' : '';
                                },
                            },
                        },
                    },
                },
            });
        }

        function ensurePlanChart() {
            if (planChart) return;
            const ctx = document.getElementById('planChart');
            planChart = new Chart(ctx, {
                data: {
                    labels: [],
                    datasets: [
                        {
                            type: 'bar',
                            label: 'Grid import (kW)',
                            data: [],
                            backgroundColor: 'rgba(37, 99, 235, 0.65)',
                            stack: 'grid',
                        },
                        {
                            type: 'bar',
                            label: 'Grid export (kW)',
                            data: [],
                            backgroundColor: 'rgba(249, 115, 22, 0.7)',
                            stack: 'grid',
                        },
                        {
                            type: 'line',
                            label: 'Battery net (kW)',
                            data: [],
                            borderColor: '#0ea5e9',
                            tension: 0.15,
                            fill: false,
                            yAxisID: 'y',
                            pointRadius: 0,
                        },
                        {
                            type: 'line',
                            label: 'Battery SoC (%)',
                            data: [],
                            borderColor: '#a855f7',
                            tension: 0.2,
                            fill: false,
                            yAxisID: 'soc',
                        },
                    ],
                },
                options: {
                    locale: activeLocale || undefined,
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { stacked: true, ticks: { maxRotation: 0, autoSkip: true } },
                        y: {
                            stacked: true,
                            title: { display: true, text: 'Grid power (kW)' },
                        },
                        soc: {
                            position: 'right',
                            min: 0,
                            max: 100,
                            grid: { drawOnChartArea: false },
                            title: { display: true, text: 'State of charge (%)' },
                        },
                    },
                    plugins: {
                        legend: { display: true },
                    },
                },
            });
        }

        function ensureHistoryChart() {
            if (historyChart) return;
            const ctx = document.getElementById('historyChart');
            historyChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Measured load (kW)',
                            data: [],
                            borderColor: '#ef4444',
                            tension: 0.2,
                            fill: false,
                        },
                        {
                            label: 'Measured PV (kW)',
                            data: [],
                            borderColor: '#22c55e',
                            tension: 0.2,
                            fill: false,
                        },
                    ],
                },
                options: {
                    locale: activeLocale || undefined,
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { ticks: { maxRotation: 0, autoSkip: true } },
                        y: {
                            title: { display: true, text: 'Power (kW)' },
                            beginAtZero: true,
                        },
                    },
                    plugins: {
                        legend: { display: true },
                    },
                },
            });
        }

        function applyForecast(payload) {
            const series = payload.series || {};
            const history = payload.history || {};
            const forecastMessage = document.getElementById('forecastMessage');
            updateFormattingContext(payload.locale, payload.timezone);
            document.getElementById('lastUpdated').textContent = formatDateTime(payload.timestamp);

            ensureForecastChart();
            ensurePlanChart();
            ensureHistoryChart();

            const timestamps = Array.isArray(series.timestamps) ? series.timestamps : [];
            const labels = timestamps.map(formatTickLabel);
            const zeros = new Array(labels.length).fill(0);

            forecastChart.data.labels = labels;
            forecastChart.data.datasets[0].data = sanitizeSeries(series.pv_kw || zeros);
            forecastChart.data.datasets[1].data = sanitizeSeries(series.load_kw || zeros);
            const priceImputedRaw = Array.isArray(series.price_imputed) ? series.price_imputed : [];
            priceImputedFlags = labels.map((_, idx) => Boolean(priceImputedRaw[idx]));
            forecastChart.data.datasets[2].data = sanitizeSeries(series.price_eur_per_kwh || zeros);
            const segmentImputed = (ctx) => {
                const leftIdx = typeof ctx.p0DataIndex === 'number' ? ctx.p0DataIndex : 0;
                const rightIdx = typeof ctx.p1DataIndex === 'number' ? ctx.p1DataIndex : leftIdx;
                return Boolean(priceImputedFlags[leftIdx] || priceImputedFlags[rightIdx]);
            };
            forecastChart.data.datasets[2].segment = {
                borderColor: () => '#6366f1',
                borderDash: (ctx) => (segmentImputed(ctx) ? [6, 4] : []),
            };
            forecastChart.data.datasets[2].pointRadius = labels.map((_, idx) => (priceImputedFlags[idx] ? 3 : 0));
            forecastChart.data.datasets[2].pointBackgroundColor = labels.map(() => '#6366f1');
            forecastChart.update();

            const importKw = Array.isArray(series.grid_import_kw) ? series.grid_import_kw : zeros;
            const exportKw = Array.isArray(series.grid_export_kw) ? series.grid_export_kw : zeros;
            const batteryNet = Array.isArray(series.battery_net_kw) ? series.battery_net_kw : zeros;
            const socSeries = Array.isArray(series.soc) ? series.soc : zeros;

            const sanitizedImport = sanitizeSeries(importKw);
            const sanitizedExport = sanitizeSeries(exportKw.map((v) => -Number(v || 0)));
            const sanitizedBatteryNet = sanitizeSeries(batteryNet);
            const sanitizedSoc = sanitizeSeries(socSeries, 100);

            planChart.data.labels = labels;
            planChart.data.datasets[0].data = sanitizedImport;
            planChart.data.datasets[1].data = sanitizedExport;
            planChart.data.datasets[2].data = sanitizedBatteryNet;
            planChart.data.datasets[2].segment = {
                borderColor: (ctx) => {
                    const idx = typeof ctx.p0DataIndex === 'number' ? ctx.p0DataIndex : 0;
                    return sanitizedBatteryNet[idx] < -1e-9 ? '#22c55e' : '#0ea5e9';
                },
            };
            planChart.data.datasets[3].data = sanitizedSoc;
            planChart.update();

            if (Array.isArray(history.timestamps) && history.timestamps.length) {
                const historyLabels = history.timestamps.map(formatTickLabel);
                const historyZeros = new Array(historyLabels.length).fill(0);
                historyChart.data.labels = historyLabels;
                historyChart.data.datasets[0].data = sanitizeSeries(history.load_kw || historyZeros);
                historyChart.data.datasets[1].data = sanitizeSeries(history.pv_kw || historyZeros);
            } else {
                historyChart.data.labels = [];
                historyChart.data.datasets[0].data = [];
                historyChart.data.datasets[1].data = [];
            }
            historyChart.update();

            updateSummary(payload.summary);
            forecastMessage.textContent = '';
            forecastMessage.classList.remove('error');

            const summaryWindowEl = document.getElementById('summaryWindow');
            if (summaryWindowEl) {
                const windowInfo = payload.summary_window || {};
                if (windowInfo.start && windowInfo.end) {
                    const startText = formatDateTime(windowInfo.start);
                    const endText = formatDateTime(windowInfo.end);
                    summaryWindowEl.textContent = `Forecast horizon: ${startText} → ${endText}`;
                } else {
                    summaryWindowEl.textContent = '';
                }
            }

            renderIntervention(payload.intervention || null);
        }

        async function refreshStatus() {
            try {
                const payload = await fetchJson('/api/status');
                applyStatus(payload);
            } catch (err) {
                const dot = document.querySelector('#status .dot');
                const label = document.getElementById('statusLabel');
                const errorEl = document.getElementById('error');
                dot.classList.remove('ok');
                label.textContent = 'Failed to reach API';
                errorEl.textContent = err instanceof Error ? err.message : String(err);
            }
        }

        async function refreshForecast() {
            const forecastMessage = document.getElementById('forecastMessage');
            forecastMessage.textContent = 'Loading latest forecast…';
            forecastMessage.classList.remove('error');
            try {
                const payload = await fetchJson('/api/forecast');
                applyForecast(payload);
            } catch (err) {
                forecastMessage.textContent = err instanceof Error ? err.message : String(err);
                forecastMessage.classList.add('error');
                renderIntervention(null, `Current intervention unavailable: ${err instanceof Error ? err.message : String(err)}`);
            }
        }

        async function triggerTraining() {
            const button = document.getElementById('trainBtn');
            button.disabled = true;
            button.textContent = 'Starting…';
            try {
                await fetchJson('/api/training', { method: 'POST' });
            } catch (err) {
                const errorEl = document.getElementById('trainingError');
                errorEl.style.display = 'block';
                errorEl.textContent = err instanceof Error ? `Failed to start training: ${err.message}` : String(err);
            }
            await refreshStatus();
            button.textContent = button.disabled ? 'Training…' : 'Trigger Training';
        }

        async function triggerCycle() {
            const button = document.getElementById('cycleBtn');
            const messageEl = document.getElementById('cycleMessage');
            if (messageEl) {
                messageEl.style.display = 'none';
                messageEl.classList.remove('error');
                messageEl.textContent = '';
                delete messageEl.dataset.auto;
            }
            if (button) {
                button.disabled = true;
                button.textContent = 'Starting…';
            }
            try {
                await fetchJson('/api/cycle', { method: 'POST' });
                if (messageEl) {
                    messageEl.style.display = 'block';
                    messageEl.textContent = 'Optimization started…';
                }
            } catch (err) {
                if (messageEl) {
                    messageEl.style.display = 'block';
                    messageEl.classList.add('error');
                    messageEl.textContent = err instanceof Error ? err.message : String(err);
                }
                if (button) {
                    button.disabled = false;
                    button.textContent = 'Recompute Plan';
                }
            }
            await refreshStatus();
            await refreshForecast();
        }

        window.addEventListener('DOMContentLoaded', () => {
            document.getElementById('refreshBtn').addEventListener('click', () => {
                refreshStatus();
                refreshForecast();
            });
            document.getElementById('trainBtn').addEventListener('click', triggerTraining);
            document.getElementById('cycleBtn').addEventListener('click', triggerCycle);
            document.getElementById('settingsBtn').addEventListener('click', toggleSettings);
            document.querySelectorAll('.settings-nav button').forEach((btn) => {
                btn.addEventListener('click', () => {
                    activateSettingsTab(btn.dataset.settingsTab);
                });
            });
            if (houseTrigger) {
                houseTrigger.addEventListener('click', () => openEntityModal('house_consumption'));
            }
            if (pvTrigger) {
                pvTrigger.addEventListener('click', () => openEntityModal('pv_power'));
            }
            if (entityModalBackdrop) {
                entityModalBackdrop.addEventListener('click', closeEntityModal);
            }
            if (entityModalClose) {
                entityModalClose.addEventListener('click', closeEntityModal);
            }
            if (entityModalCancel) {
                entityModalCancel.addEventListener('click', closeEntityModal);
            }
            if (entitySearchInput) {
                entitySearchInput.addEventListener('input', (event) => {
                    renderEntityList(event.target.value);
                });
            }
            window.addEventListener('keydown', (event) => {
                if (event.key === 'Escape' && entityModal && entityModal.classList.contains('open')) {
                    closeEntityModal();
                }
            });

            refreshStatus();
            refreshForecast();
            loadSettingsData();
            updateViewMode();
            renderIntervention(null, 'Current intervention: Waiting for forecast…');
            activateSettingsTab('inverter');

            setInterval(() => {
                if (!showingSettings) {
                    refreshStatus();
                    refreshForecast();
                }
            }, 5 * 60 * 1000);
        });
    </script>
</body>
</html>
